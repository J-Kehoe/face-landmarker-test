/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import { uvMap } from "../helpers/uvMap.ts";
import * as THREE from "three";
import { 
  // Text, 
  useGLTF 
} from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useLoader } from "@react-three/fiber";
// import { OBJLoader } from "three/examples/jsm/Addons.js";

type GLTFResult = GLTF & {
  nodes: {
    mesh_0: THREE.Mesh;
  };
  materials: {};
};

export function CanonFace(props: any) {
  let map: THREE.Texture;
  if (props.map) {
    // @ts-ignore
    map = useLoader(THREE.TextureLoader, props.map);
    map.mapping = THREE.UVMapping
  }

  const { 
    nodes, 
    //materials 
  } = useGLTF(
    "/canonical_face_model.gltf"
  ) as GLTFResult;

  // const faceObj = useLoader(OBJLoader, "/canonical_face_model.obj");
  // const faceGeometry = faceObj.children[0].geometry as THREE.BufferGeometry
  // const faceUvs = faceGeometry.getAttribute("uv");

  var uvAttribute = nodes.mesh_0.geometry.attributes["uv"];
  var positionAttribute = nodes.mesh_0.geometry.attributes["position"];

  var uvPoints: { i: any; x: any; y: any; z: any }[] = [];
  var positionPoints: { i: any; x: any; y: any; z: any }[] = [];

  let uniquePoints: { id: any; indices: any[]; x: any; y: any; z: any }[] = [];
  let uniquePositionPoints: { id: any; indices: any[]; x: any; y: any; z: any }[] = [];

  if (props.keypoints.length !== 0) {

    console.log(`uvAttribute.count: ${uvAttribute.count}`);
    
    for (var i = 0; i < uvAttribute.count; i++) {
      var u = uvAttribute.getX(i);
      var v = uvAttribute.getY(i);
      var z = uvAttribute.getZ(i);

      uvPoints.push({ i: i, x: u, y: v, z: z });
    }

    for (var i = 0; i < positionAttribute.count; i++) {
      var posX = positionAttribute.getX(i);
      var posY = positionAttribute.getY(i);
      var posZ = positionAttribute.getZ(i);

      positionPoints.push({ i: i, x: posX, y: posY, z: posZ });
    }

    let uvPointCount = 0;
    for (let i = 0; i < uvPoints.length; i++) {
      if (
        !uniquePoints.some(
          (el) => el.x === uvPoints[i].x && el.y === uvPoints[i].y
        )
      ) {
        uniquePoints.push({ id: uvPointCount, indices: [i], ...uvPoints[i] });
        uvPointCount++;
      } else {
        // add index to array of indices for that point
        const index = uniquePoints.findIndex(
          (el) => el.x === uvPoints[i].x && el.y === uvPoints[i].y
        );
        uniquePoints[index].indices.push(uvPoints[i].i);
      }
    }

    console.log(`uniquePoints: ${uniquePoints.length}`);

    let positionPointCount = 0;
    for (let i = 0; i < positionPoints.length; i++) {
      if (
        !uniquePositionPoints.some(
          (el) => el.x === positionPoints[i].x && el.y === positionPoints[i].y
        )
      ) {
        uniquePositionPoints.push({ id: positionPointCount, indices: [i], ...positionPoints[i] });
        positionPointCount++;
      } else {
        // add index to array of indices for that point
        const index = uniquePositionPoints.findIndex(
          (el) => el.x === positionPoints[i].x && el.y === positionPoints[i].y
        );
        uniquePositionPoints[index].indices.push(positionPoints[i].i);
      }
    }

    console.log(`uniquePositionPoints: ${uniquePositionPoints.length}`);

    for (var i = 0; i < uvAttribute.count; i++) {
      var u = uvAttribute.getX(i);
      var v = uvAttribute.getY(i);

      // do something with uv
      const point = uniquePoints.find((el) => el.indices.includes(i));
      const positionPoint = uniquePositionPoints.find((el) => el.indices.includes(i));
      const uvPoint = uvMap.find((x) => x.meshUv === positionPoint?.id)!
      if (point === null || point === undefined) {
        console.log("point is null")
        return;
      }
      if (positionPoint === null || positionPoint === undefined) {
        console.log("position point is null")
        return;
      }
      var x = props.keypoints[uvPoint?.texUv].x
      var y = 1 - props.keypoints[uvPoint?.texUv].y;
      u = x
      v = y

      // write values back to attribute
      uvAttribute.setXY(i, u, v);
    }
  }

  return (
    <>
      <group {...props} dispose={null}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.mesh_0.geometry}
          material={
            new THREE.MeshStandardMaterial({
              flatShading: true,
              // @ts-ignore
              map: map || null,
              side: THREE.DoubleSide,
            })
          }
        />
      </group>

      {/* helpers */}
      <group dispose={null}>
        {uniquePoints.map((keypoint: any, index: number) => {
          if (keypoint.id === props.focusPoint) {
            return (
              <mesh key={index} position={[keypoint.x, keypoint.y, 0.001]} visible={props.numVisible}>
                {/* <sphereGeometry args={[0.005, 32, 32]} /> */}
                {/* <Text scale={[0.01, 0.01, 0.01]} color={"green"}>
                  {keypoint.id}
                </Text>
                <meshStandardMaterial color="yellow" /> */}
              </mesh>
            );
          } else {
            return (
              <mesh key={index} position={[keypoint.x, keypoint.y, 0.001]} visible={props.numVisible}>
                {/* <sphereGeometry args={[0.005, 32, 32]} /> */}
                {/* <Text scale={[0.008, 0.008, 0.008]} color={"red"}>
                  {keypoint.id}
                </Text>
                <meshStandardMaterial color="red" /> */}
              </mesh>
            );
          }
        })}
      </group>
      <group dispose={null}>
        {uniquePositionPoints.map((keypoint: any, index: number) => {
          if (keypoint.id === props.focusPoint) {
            return (
              <mesh key={index} position={[keypoint.x * 0.1 + 1.5, keypoint.y * 0.1, keypoint.z * 0.1 + 0.05]}>
                {/* <sphereGeometry args={[0.05, 32, 32]} /> */}
                {/* <Text scale={[0.05, 0.05, 0.05]} color={"green"}>
                  {keypoint.id}
                </Text>
                <meshStandardMaterial color="red" /> */}
              </mesh>
            );
          } else {
            return (
              <mesh key={index} position={[keypoint.x * 0.1 + 1.5, keypoint.y * 0.1, keypoint.z * 0.1 + 0.05]}>
                {/* <sphereGeometry args={[0.05, 32, 32]} /> */}
                {/* <Text scale={[0.01, 0.01, 0.01]} color={"blue"}>
                  {keypoint.id}
                </Text>
                <meshStandardMaterial color="red" /> */}
              </mesh>
            );
          }
        })}
      </group>
      {/* <group dispose={null}>
        {uvPoints.map((keypoint: any, index: number) => {
          return (
            <mesh key={index} position={[keypoint.x, keypoint.y, keypoint.z * 0.01]}>
              <sphereGeometry args={[0.005, 32, 32]} />
              <meshStandardMaterial color="red" />
            </mesh>
          );
        })}
      </group> */}
      {/* <group dispose={null}>
        {positionPoints.map((keypoint: any, index: number) => {
          return (
            <mesh key={index} position={[keypoint.x * 0.1 + 1.5, keypoint.y * 0.1, keypoint.z * 0.1]}>
              <sphereGeometry args={[0.01, 32, 32]} />
              <meshStandardMaterial color="red" />
            </mesh>
          );
        })}
      </group> */}
    </>
  );
}

useGLTF.preload("/canonical_face_model.gltf");
